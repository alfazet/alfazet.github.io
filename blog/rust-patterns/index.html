<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://alfazet.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>αzet | Rust is all about patterns</title><link as=style href=https://alfazet.github.io/css/style.css rel=preload><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/reset-min.css rel=stylesheet><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css rel=stylesheet><link href=https://alfazet.github.io/css/style.css rel=stylesheet><link href=https://alfazet.github.io/css/custom.css rel=stylesheet><body><nav id=nav-bar><a href=/> /home </a><a href=/about> /about </a><div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://alfazet.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://alfazet.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2025-11-08>Published on: <span class=accent-data>2025-11-08</span> </time><h1>Rust is all about patterns</h1></header><div class=post-content><p>Everyone who is at least a bit familiar with Rust knows about the <code>match</code> statement and how it matches the given value against patterns.<p>Here’s a simple example of it:<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> n </span><span style=color:#fe8019>= </span><span style=color:#d3869b>14</span><span>;
</span><span style=color:#fa5c4b>match</span><span> n {
</span><span>    </span><span style=color:#d3869b>0 </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>println!</span><span>(</span><span style=color:#b8bb26>"n is zero"</span><span>),
</span><span>    </span><span style=color:#d3869b>1</span><span style=color:#fe8019>..=</span><span style=color:#d3869b>9 </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>println!</span><span>(</span><span style=color:#b8bb26>"n is a one-digit number"</span><span>),
</span><span>    </span><span style=color:#d3869b>10 </span><span style=color:#fe8019>| </span><span style=color:#d3869b>11 </span><span style=color:#fe8019>| </span><span style=color:#d3869b>12 </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>println!</span><span>(</span><span style=color:#b8bb26>"n is in range [10, 12]"</span><span>),
</span><span>    </span><span style=color:#d3869b>13</span><span style=color:#fe8019>..=</span><span style=color:#d3869b>19 </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>println!</span><span>(</span><span style=color:#b8bb26>"n ends with `teen`"</span><span>),
</span><span>    </span><span style=color:#fe8019>_ => </span><span style=color:#fabd2f>println!</span><span>(</span><span style=color:#b8bb26>"n is some other number"</span><span>),
</span><span>}
</span></code></pre><p>Now, writing such code is possible in any programming language just by using a couple of <code>if</code> statements. At worst it would just look less concise.<p>However, Rust’s pattern matching is much more powerful than that. Namely, it allows us to reason about <em>the shape of data</em>, not only its value. And that is an immensly powerful concept that permeates through the language.<p>And by “permeates” I really mean it. Let’s take a look at the humble <code>let</code> keyword. It’s most often used when declaring variables:<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> x </span><span style=color:#fe8019>= </span><span style=color:#d3869b>42</span><span>;
</span><span style=color:#fa5c4b>let</span><span> name </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>"Ferris"
</span></code></pre><p>so you’d think that it works as follows:<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let </span><span style=color:#fdf4c1>VARIABLE </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>EXPRESSION
</span></code></pre><p>but you’d be wrong. In reality, the syntax is:<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let </span><span style=color:#fdf4c1>PATTERN </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>EXPRESSION
</span></code></pre><p>So even the first Rust keyword you learn is a pattern match under the hood!<p>Because of it, we don’t have to write code like:<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> p </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#d3869b>0.0</span><span>, </span><span style=color:#d3869b>2.137</span><span>, </span><span style=color:#d3869b>3.14</span><span>);
</span><span style=color:#fa5c4b>let</span><span> x </span><span style=color:#fe8019>=</span><span> p.</span><span style=color:#d3869b>0</span><span>;
</span><span style=color:#fa5c4b>let</span><span> y </span><span style=color:#fe8019>=</span><span> p.</span><span style=color:#d3869b>1</span><span>;
</span><span style=color:#fa5c4b>let</span><span> z </span><span style=color:#fe8019>=</span><span> p.</span><span style=color:#d3869b>2</span><span>;
</span></code></pre><p>Instead, we can use this snippet which does the same, but in an elegant way.<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> p </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#d3869b>0.0</span><span>, </span><span style=color:#d3869b>2.137</span><span>, </span><span style=color:#d3869b>3.14</span><span>);
</span><span style=color:#fa5c4b>let </span><span>(x, y, z) </span><span style=color:#fe8019>=</span><span> p;
</span></code></pre><p>Let’s take a closer look at the last line - we’re declaring variables <code>x</code>, <code>y</code> and <code>z</code> by matching <code>p</code> (which has a form of <code>(f32, f32, f32)</code>) against the pattern <code>(x, y, z)</code>. Clearly, the first number matches the <code>x</code> “slot”, the second the <code>y</code> “slot” and the the <code>z</code> “slot” - so we get <code>x = 0.0</code>, <code>y = 2.137</code> and <code>z = 3.14</code>.<p>The power of pattern matching also makes the following code invalid, since there’s no place for the third member of <code>p</code> in the left-hand side pattern.<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let </span><span>(x, y) </span><span style=color:#fe8019>=</span><span> p; </span><span style=color:#928374;font-style:italic>// doesn't compile
</span></code></pre><p>To finish up, let’s check out another example of pattern matching being a handy tool that saves lines of code.<p>Imagine a 3D rendering engine that renders a simple scene with a light source and one object. That object will have a lot of paramaters that describe the way light rays will interact with it - a color, a specular constant, a diffuse constant and more (the specifics don’t matter here). Let’s say these parameters are stored in a stuct like the one here:<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>struct </span><span style=color:#8ec07c>SurfaceParams </span><span>{
</span><span>    </span><span style=color:#fdf4c1>color</span><span>: Rgb,
</span><span>    </span><span style=color:#fdf4c1>k_s</span><span>: </span><span style=color:#fa5c4b>f32</span><span>,
</span><span>    </span><span style=color:#fdf4c1>k_d</span><span>: </span><span style=color:#fa5c4b>f32</span><span>,
</span><span>    </span><span style=color:#fdf4c1>k_a</span><span>: </span><span style=color:#fa5c4b>f32</span><span>,
</span><span>    </span><span style=color:#928374;font-style:italic>// and more
</span><span>}
</span></code></pre><p>Now let’s pass <code>SurfaceParams</code> to a rendering function. Our first instinct is to pass a reference to the entire struct. But then using individual parameters inside the function will become quite verbose.<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>render</span><span>(</span><span style=color:#fdf4c1>surf_params</span><span>: </span><span style=color:#fe8019>&</span><span>SurfaceParams) {
</span><span>    </span><span style=color:#928374;font-style:italic>// ...
</span><span>    </span><span style=color:#fa5c4b>let</span><span> specular </span><span style=color:#fe8019>=</span><span> surf_params.k_s </span><span style=color:#fe8019>*</span><span> surf_params.color </span><span style=color:#fe8019>*
</span><span>        angle.</span><span style=color:#fabd2f>cos</span><span>().</span><span style=color:#fabd2f>powf</span><span>(surf_params.alpha) </span><span style=color:#fe8019>*</span><span> light_color;
</span><span>    </span><span style=color:#928374;font-style:italic>// ...
</span><span>}
</span></code></pre><p>To avoid constantly writing the <code>surf_params</code> prefix, we could pass each parameter as a separate variable. But that isn’t an approach that scales well.<p>Instead, let’s use the fact that <em>function parameters are patterns too</em>.<pre class=language-rust data-lang=rust style=color:#fdf4c1aa;background-color:#282828><code class=language-rust data-lang=rust><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>render</span><span>(SurfaceParams { color, k_s, k_d, k_a, </span><span style=color:#928374;font-style:italic>/* ... */</span><span> }: </span><span style=color:#fe8019>&</span><span>SurfaceParams) {
</span><span>    </span><span style=color:#928374;font-style:italic>// ...
</span><span>    </span><span style=color:#fa5c4b>let</span><span> specular </span><span style=color:#fe8019>=</span><span> k_s </span><span style=color:#fe8019>*</span><span> color </span><span style=color:#fe8019>*</span><span> angle.</span><span style=color:#fabd2f>cos</span><span>().</span><span style=color:#fabd2f>powf</span><span>(alpha) </span><span style=color:#fe8019>*</span><span> light_color;
</span><span>    </span><span style=color:#928374;font-style:italic>// ...
</span><span>}
</span></code></pre><p>The number of arguments of our function hasn’t exploded <em>and</em> we don’t need to verbosely name the entire struct every time we want to reference a parameter. I learned about this syntax only recently and I wish I had known it sooner, it’s so nice!<p>As you might expect, this isn’t all there is to pattern matching in Rust. For the curious, an in-depth explanation is available <a href=https://doc.rust-lang.org/book/ch19-01-all-the-places-for-patterns.html rel=noopener target=_blank>here</a>. It really is a powerful feature of the language that often goes unnoticed.</div></article></main><footer><hr><div id=footer-container><p>made with <a href=https://www.getzola.org target=_blank>Zola</a>, theme based on <a href=https://github.com/Speyll/anemone target=_blank>anemone</a></div></footer><script defer src=https://alfazet.github.io/js/script.js></script>